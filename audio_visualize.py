# -*- coding: utf-8 -*-
"""audio_visualize.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1awWsfOmcQUQgCofEqWTqrdntywjIIlyO
"""

!pip install animatplot

import numpy as np, scipy, matplotlib.pyplot as plt, sklearn, librosa, urllib, IPython.display
import librosa.display
from scipy import signal
from PIL import Image
from PIL import ImageFilter
#import animatplot as amp
from matplotlib.animation import FuncAnimation
import math

url = 'https://www2.cs.uic.edu/~i101/SoundFiles/CantinaBand60.wav'
urllib.request.urlretrieve(url, filename='CantinaBand60.wav')

x, fs = librosa.load('CantinaBand60.wav') # x is time series, fs = sampling rate

# if necessary, convert to mono by averaging the left and right channels
if len(x.shape) > 1:
  x = np.mean(x, axis=1)

audio = x
N = audio.shape[0]
L = N / fs # length

print(f'Audio length: {L:.2f} seconds')

# process image

# get spectrogram
M = 1024

freqs, times, Sx = signal.spectrogram(x, fs=fs, window='hanning',
                                      nperseg=1024, noverlap=M - 100,
                                      detrend=False, scaling='spectrum')

# Sx = spectrogram --> amp of each freq at each time

f, ax = plt.subplots(figsize=(4.8, 2.4))
ax.pcolormesh(times, freqs / 1000, 10 * np.log10(Sx), cmap="twilight") #viridis is good only if you actually want to read the data
ax.set_ylabel('Frequency [kHz]')
ax.set_xlabel('Time [s]');

# plots max frequency vs time

# gives the time at which each frequency is a maximum
max_freq = np.argmax(Sx, axis = 0)
# max freq at each time step
l_full = np.array(freqs[max_freq])

# length of time we want to view information for, increase the number of frames to have more rings
length = 300

# define frames at negative time so circles spread outwards
# all frequencies before time 0 is 0 / 'black'
# l_full = np.concatenate([np.zeros((length,)), l_full, np.zeros((length,))], axis = 0)
# base negative time steps on time array by making everything negative
# start indexing at 1 to skip time = 0
# times_full = np.concatenate([np.flip(-1*times[1:length]), times, times[1:length]+times[-1]], axis = 0)
times_full = times

######### loop should start here by adjusting frame_start ##########
arr = []

for t in range(0, len(times_full) - length):
  if t>99 and t%1000 == 0:
    print(t)

  # starts at 0, time = 0 occurs at time[length]
  frame_start = t
  frame_end = frame_start + length

  # make time start at 0, and normalize frequency to have a scale of 1
  # crop to only look at times of interest
  times = times_full[frame_start:frame_end]
  times = (times-times[0])

  l = l_full[frame_start:frame_end]
  l = l*1/np.max(abs(l) + 1e-16)

  # adapted from https://stackoverflow.com/questions/30608035/plot-circular-gradients-using-pil-in-python

  imgsize = (len(times), len(times)) #The size of the image

  image = Image.new('L', imgsize) #Create the image

  for y in range(0, len(times)-1):
      for x in range(0, len(times)-1):
          #Find the distance to the center
          distanceToCenter = math.sqrt((x - imgsize[0]/2) ** 2 + (y - imgsize[1]/2) ** 2)

          color = l[int(distanceToCenter)]

          #Calculate greyscale values
          L = 255 * color

          #Place the pixel
          image.putpixel((x, y), (int(L)))

  # use a blur instead of math to make the gradient because math is hard
  # higher radius == blurrier image
  blurred_image = image.filter(ImageFilter.GaussianBlur(2))
  # blurred_image.save('circlegradient{}.jpg'.format(t))
  # blurred_image_arr = np.asarray(blurred_image)
  arr.append(blurred_image)
  #plt.pcolormesh(blurred_image_arr, cmap='gray')

arr2 = arr
print(len(arr))

import glob
fp_out = "0110.gif"

arr2[0].save(fp=fp_out, format='GIF', append_images=arr2,
         save_all=True, duration=60, loop=0)

# fp_in = "circlegradient*.jpg"
# https://pillow.readthedocs.io/en/stable/handbook/image-file-formats.html#gif
# img, *imgs = [Image.open(f) for f in sorted(glob.glob(fp_in))]
# img.save(fp=fp_out, format='GIF', append_images=imgs,
#          save_all=True, duration=200, loop=0)

from google.colab import drive
drive.mount('/content/drive')

